# PacketBuddy Architecture - TOON Format

[meta]
doc_type = "architecture"
updated = "2026-01-10"

[layers]
presentation = ["Web Dashboard (HTML/CSS/JS)", "CLI (Python argparse)"]
application = ["FastAPI Server", "API Routes"]
business = ["Network Monitor", "Data Validation", "Cost Calculation"]
data = ["Storage (SQLite)", "Sync (NeonDB)", "Config (TOML)"]

[components.monitor]
file = "src/core/monitor.py"
pattern = "Observer"
tech = "psutil + asyncio + native netstat (macOS)"
flow = "psutil/netstat → calculate delta → validate → filter → storage"
features = {reset_detection="Skip on counter reset", anomaly_filter=">1GB/s rejected", auto_interface="Detects active NIC", macos_64bit="Uses netstat -ib for 64-bit accuracy"}

[components.storage]
file = "src/core/storage.py"
pattern = "Repository"
db = "SQLite"
schema = """
network_usage(id, timestamp, bytes_sent, bytes_received, device_id, synced)
device_info(device_id, hostname, platform, created_at)
indexes: timestamp, device_timestamp, synced
"""
optimization = {batch_writes="Every 30s", indexed_queries="O(log n)", connection_pooling="Reuse conn"}

[components.sync]
file = "src/core/sync.py"
pattern = "Eventual Consistency"
flow = "Local SQLite (source of truth) → Sync Manager → NeonDB (aggregation)"
algorithm = "Get unsynced (synced=0) → Bulk insert NeonDB → Mark synced (synced=1)"
retry = "Exponential backoff: min(60 * 2^retry_count, 3600)"

[components.api]
file = "src/api/server.py"
pattern = "RESTful API"
tech = "FastAPI + uvicorn"
endpoints = {
  health = "GET /api/health → {status, hostname}",
  live = "GET /api/live → current speed",
  today = "GET /api/today → today's usage",
  month = "GET /api/month?month=YYYY-MM → daily breakdown",
  summary = "GET /api/summary → lifetime totals",
  export = "GET /api/export?format=json|csv → all data"
}
response_format = "{bytes_sent, bytes_received, total_bytes, human_readable{sent, received, total}, cost{...}}"

[data_flow.write]
steps = [
  "psutil.net_io_counters() or netstat -ib (macOS)",
  "Monitor calculates delta",
  "Validate (no resets, no anomalies)",
  "Add to write buffer",
  "Batch write to SQLite (every 30s)",
  "Mark as unsynced (synced=0)",
  "Sync to NeonDB (every 60s)",
  "Mark as synced (synced=1)"
]

[data_flow.read]
steps = [
  "Dashboard requests /api/today",
  "API route handler",
  "Storage.get_today_usage()",
  "SQL: SELECT SUM(...) WHERE date(timestamp)=today",
  "Format response (bytes → human-readable)",
  "Calculate cost (bytes * rate_per_gb)",
  "Return JSON",
  "Dashboard updates UI"
]

[service.windows]
mechanism = "Task Scheduler"
flow = "User Login → Task Scheduler → run-service.bat → Sets PYTHONPATH → pythonw.exe -m src.api.server"
watchdog = "watchdog.bat → Monitors API /health every 30s → Restarts main task if down"
fix_v1_0_1 = "Created run-service.bat to set PYTHONPATH (was missing)"
fix_v1_1_2 = "Enhanced error handling, validates each step"

[service.macos]
mechanism = "LaunchAgent (launchd)"
flow = "User Login → launchd → com.packetbuddy.plist → python -m src.api.server"
plist_location = "~/Library/LaunchAgents/"

[service.linux]
mechanism = "systemd user service"
flow = "User Login → systemd --user → packetbuddy.service → python -m src.api.server"
service_location = "~/.config/systemd/user/"

[concurrency]
model = "async/await"
event_loop = "asyncio"
tasks = ["FastAPI server", "Monitor loop", "Sync loop (if enabled)"]
benefits = ["Non-blocking I/O", "Efficient resources", "Graceful shutdown"]

[error_handling]
monitor = "Try/except → log error → sleep → continue (skip sample)"
storage = "Try/except → rollback transaction → data stays in buffer → retry"
sync = "Try/except → log warning → exponential backoff → retry later"
api = "Try/except → HTTPException(500) → log error"

[security]
network = "Bind to 127.0.0.1 only (no external access)"
privacy = "Only collect: bytes_sent, bytes_received, timestamp, device_id"
credentials = "Environment variables (NEON_DB_URL)"
neondb = "TLS (sslmode=require)"

[performance]
batch_writing = "1 write/sec → 1 write/30sec = 97% reduction in disk I/O"
indexed_queries = "O(n) scan → O(log n) lookup with indexes"
connection_pooling = "Reuse DB connection instead of creating new"
async_io = "Non-blocking network I/O"

[scalability]
current_limits = {db_size="~1MB/month/device", api_throughput="1000+ req/s", devices="Unlimited (with NeonDB)", retention="10+ years on free tier"}
future_scaling = ["Partition DB by month", "Archive to cold storage", "Add Redis cache", "Horizontal scaling with load balancer"]

[tech_stack_rationale]
python = "Cross-platform, excellent libraries, good for I/O-bound tasks"
fastapi = "Modern, fast, automatic docs, async support"
sqlite = "Zero config, serverless, ACID, perfect for local storage"
neondb = "Free tier (10GB), serverless PostgreSQL, easy multi-device"
chartjs = "Lightweight, beautiful charts, no build process"

[design_principles]
local_first = "Works 100% offline, cloud sync optional"
zero_config = "Auto-detects interface, sensible defaults, one-command install"
privacy = "Minimal data collection, local storage first"
cross_platform = "Same codebase, platform-specific installers"
lightweight = "<40MB RAM, <0.5% CPU, minimal disk I/O"
resilient = "Handles interruptions, survives sleep/resume, auto-recovery (Windows Watchdog)"
